// Copyright 2016-2020, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using Pulumi.Kubernetes.Yaml;
using Pulumi.Utilities;

namespace Pulumi.Kubernetes.Helm.V2
{
    /// <summary>
    /// Chart is a component representing a collection of resources described by an arbitrary Helm
    /// Chart. The Chart can be fetched from any source that is accessible to the `helm` command
    /// line. Values in the `values.yml` file can be overridden using
    /// <see cref="BaseChartArgsUnwrap.Values" /> (equivalent to `--set` or having multiple
    /// `values.yml` files). Objects can be transformed arbitrarily by supplying callbacks to
    /// <see cref="BaseChartArgsUnwrap.Transformations" />.
    /// <para />
    /// <see cref="Chart"/> does not use Tiller. The Chart specified is copied and expanded locally;
    /// the semantics are equivalent to running `helm template` and then using Pulumi to manage the
    /// resulting YAML manifests. Any values that would be retrieved in-cluster are assigned fake
    /// values, and none of Tiller's server-side validity testing is executed.
    ///
    /// ## Example Usage
    /// ### Local Chart Directory
    ///
    /// ```csharp
    /// using System.Threading.Tasks;
    /// using Pulumi;
    /// using Pulumi.Kubernetes.Helm;
    /// using Pulumi.Kubernetes.Helm.V2;
    ///
    /// class HelmStack : Stack
    /// {
    ///     public HelmStack()
    ///     {
    ///         var nginx = new Chart("nginx-ingress", new LocalChartArgs
    ///         {
    ///             Path = "./nginx-ingress",
    ///         });
    ///
    ///     }
    /// }
    /// ```
    /// ### Remote Chart
    ///
    /// ```csharp
    /// using System.Threading.Tasks;
    /// using Pulumi;
    /// using Pulumi.Kubernetes.Helm;
    /// using Pulumi.Kubernetes.Helm.V2;
    ///
    /// class HelmStack : Stack
    /// {
    ///     public HelmStack()
    ///     {
    ///         var nginx = new Chart("nginx-ingress", new ChartArgs
    ///         {
    ///             Chart = "nginx-ingress",
    ///             Version = "1.24.4",
    ///             FetchOptions = new ChartFetchArgs
    ///             {
    ///                 Repo = "https://kubernetes-charts.storage.googleapis.com/"
    ///             }
    ///         });
    ///
    ///     }
    /// }
    /// ```
    /// ### Set Chart Values
    ///
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Threading.Tasks;
    /// using Pulumi;
    /// using Pulumi.Kubernetes.Helm;
    /// using Pulumi.Kubernetes.Helm.V2;
    ///
    /// class HelmStack : Stack
    /// {
    ///     public HelmStack()
    ///     {
    ///         var values = new Dictionary&lt;string, object&gt;
    ///         {
    ///             ["controller"] = new Dictionary&lt;string, object&gt;
    ///             {
    ///                 ["metrics"] = new Dictionary&lt;string, object&gt;
    ///                 {
    ///                     ["enabled"] = true
    ///                 }
    ///             },
    ///         };
    ///
    ///         var nginx = new Chart("nginx-ingress", new ChartArgs
    ///         {
    ///             Chart = "nginx-ingress",
    ///             Version = "1.24.4",
    ///             FetchOptions = new ChartFetchArgs
    ///             {
    ///                 Repo = "https://kubernetes-charts.storage.googleapis.com/"
    ///             },
    ///             Values = values,
    ///         });
    ///
    ///     }
    /// }
    /// ```
    /// ### Deploy Chart into Namespace
    ///
    /// ```csharp
    /// using System.Threading.Tasks;
    /// using Pulumi;
    /// using Pulumi.Kubernetes.Helm;
    /// using Pulumi.Kubernetes.Helm.V2;
    ///
    /// class HelmStack : Stack
    /// {
    ///     public HelmStack()
    ///     {
    ///         var nginx = new Chart("nginx-ingress", new ChartArgs
    ///         {
    ///             Chart = "nginx-ingress",
    ///             Version = "1.24.4",
    ///             Namespace = "test-namespace",
    ///             FetchOptions = new ChartFetchArgs
    ///             {
    ///                 Repo = "https://kubernetes-charts.storage.googleapis.com/"
    ///             },
    ///         });
    ///
    ///     }
    /// }
    /// ```
    /// ### Chart with Transformations
    ///
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Collections.Immutable;
    /// using System.Threading.Tasks;
    /// using Pulumi;
    /// using Pulumi.Kubernetes.Helm;
    /// using Pulumi.Kubernetes.Helm.V2;
    ///
    /// class HelmStack : Stack
    /// {
    ///     public HelmStack()
    ///     {
    ///         var nginx = new Chart("nginx-ingress", new ChartArgs
    ///         {
    ///             Chart = "nginx-ingress",
    ///             Version = "1.24.4",
    ///             FetchOptions = new ChartFetchArgs
    ///             {
    ///                 Repo = "https://kubernetes-charts.storage.googleapis.com/"
    ///             },
    ///             Transformations =
    ///             {
    ///                 LoadBalancerToClusterIP,
    ///                 ResourceAlias,
    ///                 OmitTestPod,
    ///             }
    ///
    ///         });
    ///
    ///         // Make every service private to the cluster, i.e., turn all services into ClusterIP instead of LoadBalancer.
    ///         ImmutableDictionary&lt;string, object&gt; LoadBalancerToClusterIP(ImmutableDictionary&lt;string, object&gt; obj, CustomResourceOptions opts)
    ///         {
    ///             if ((string)obj["kind"] == "Service" &amp;&amp; (string)obj["apiVersion"] == "v1")
    ///             {
    ///                 var spec = (ImmutableDictionary&lt;string, object&gt;)obj["spec"];
    ///                 if (spec != null &amp;&amp; (string)spec["type"] == "LoadBalancer")
    ///                 {
    ///                     return obj.SetItem("spec", spec.SetItem("type", "ClusterIP"));
    ///                 }
    ///             }
    ///
    ///             return obj;
    ///         }
    ///
    ///         // Set a resource alias for a previous name.
    ///         ImmutableDictionary&lt;string, object&gt; ResourceAlias(ImmutableDictionary&lt;string, object&gt; obj, CustomResourceOptions opts)
    ///         {
    ///             if ((string)obj["kind"] == "Deployment")
    ///             {
    ///                 opts.Aliases.Add(new Alias { Name = "oldName" });
    ///             }
    ///
    ///             return obj;
    ///         }
    ///
    ///         // Omit a resource from the Chart by transforming the specified resource definition to an empty List.
    ///         ImmutableDictionary&lt;string, object&gt; OmitTestPod(ImmutableDictionary&lt;string, object&gt; obj, CustomResourceOptions opts)
    ///         {
    ///             var metadata = (ImmutableDictionary&lt;string, object&gt;)obj["metadata"];
    ///             if ((string)obj["kind"] == "Pod" &amp;&amp; (string)metadata["name"] == "test")
    ///             {
    ///                 return new Dictionary&lt;string, object&gt;
    ///                 {
    ///                     ["apiVersion"] = "v1",
    ///                     ["kind"] = "List",
    ///                     ["items"] = new Dictionary&lt;string, object&gt;(),
    ///                 }.ToImmutableDictionary();
    ///             }
    ///
    ///             return obj;
    ///         }
    ///     }
    /// }
    /// ```
    /// </summary>
    public sealed class Chart : CollectionComponentResource
    {
        /// <summary>
        /// Create a Chart resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="releaseName">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Chart(string releaseName, Union<ChartArgs, LocalChartArgs> args, ComponentResourceOptions? options = null)
            : base("kubernetes:helm.sh/v2:Chart", GetName(args, releaseName), options)
        {
            releaseName = GetName(args, releaseName);
            var config = args.Unwrap();

            var configDeps = Output.Create(OutputUtilities.GetDependenciesAsync(config));
            OutputUtilities.GetIsKnownAsync(config).ContinueWith(isKnown =>
            {
                if (!isKnown.Result)
                {
                    // Note that this can only happen during a preview.
                    Log.Info("[Can't preview] all chart values must be known ahead of time to generate an accurate preview.", this);
                }
            });

            var resources = Output.Tuple(config, configDeps).Apply(values =>
            {
                var chartArgs = values.Item1;
                var dependencies = values.Item2;

                // Create temporary directories and files to hold chart data and override values.
                var overrides = Path.GetTempFileName();
                var chartDirectoryName = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
                var chartDirectory = Directory.CreateDirectory(chartDirectoryName);

                try
                {
                    string chart;
                    string defaultValues;
                    BaseChartArgsUnwrap cfgBase;
                    if (chartArgs.IsT0)
                    {
                        var cfg = chartArgs.AsT0;
                        // Fetch chart.
                        if (cfg.Repo != null && cfg.Repo.Contains("http"))
                        {
                            throw new Exception(
                                $"`{nameof(cfg.Repo)}` specifies the name of the Helm chart repo. Use `{nameof(ChartArgs)}.{nameof(cfg.Repo)}` to specify a URL.");
                        }

                        var chartToFetch = !string.IsNullOrEmpty(cfg.Repo) ? $"{cfg.Repo}/{cfg.Chart}" : cfg.Chart;
                        var fetchOptions = cfg.FetchOptions ?? new ChartFetchArgsUnwrap();
                        fetchOptions.Destination = chartDirectoryName;
                        fetchOptions.Version = cfg.Version;
                        Fetch(chartToFetch, fetchOptions);
                        // Sort the directories into alphabetical order, and choose the first
                        var fetchedChart = chartDirectory.GetDirectories().OrderBy(x => x.Name).ToArray()[0];
                        var fetchedChartName = fetchedChart.Name;
                        chart = fetchedChart.FullName;
                        defaultValues = Path.Join(chartDirectoryName, fetchedChartName, "values.yaml");
                        cfgBase = cfg;
                    }
                    else
                    {
                        var cfg = chartArgs.AsT1;
                        chart = cfg.Path;
                        defaultValues = Path.Join(chart, "values.yaml");
                        cfgBase = cfg;
                    }

                    // Write overrides file.
                    var data = JsonSerializer.Serialize(cfgBase.Values);
                    File.WriteAllText(overrides, data);

                    // Does not require Tiller. From the `helm template` documentation:
                    //
                    // >  Render chart templates locally and display the output.
                    // >
                    // > This does not require Tiller. However, any values that would normally be
                    // > looked up or retrieved in-cluster will be faked locally. Additionally, none
                    // > of the server-side testing of chart validity (e.g. whether an API is supported)
                    // > is done.
                    var flags = new List<string>(new[]
                    {
                        "template", chart,
                        "--name-template", releaseName,
                        "--values", defaultValues,
                        "--values", overrides
                    });
                    if (cfgBase.ApiVersions.Length > 0)
                    {
                        flags.Add("--api-versions");
                        flags.Add(string.Join(",", cfgBase.ApiVersions));
                    }

                    if (!string.IsNullOrEmpty(cfgBase.Namespace))
                    {
                        flags.Add("--namespace");
                        flags.Add(cfgBase.Namespace);
                    }

                    if (IsHelmV3())
                    {
                        flags.Add("--include-crds");
                    }

                    var yaml = ExecuteCommand("helm", flags.ToArray(), new Dictionary<string, string>());
                    return ParseTemplate(
                        yaml, cfgBase.Transformations, cfgBase.ResourcePrefix, dependencies, cfgBase.Namespace);
                }
                catch (Exception e)
                {
                    // Shed stack trace, only emit the error.
                    throw new ResourceException(e.Message, this);
                }
                finally
                {
                    chartDirectory.Delete(true);
                }
            });
            RegisterResources(resources);
        }
        private static string GetName(Union<ChartArgs, LocalChartArgs> config, string releaseName)
        {
            var prefix = config.Match(v => v.ResourcePrefix, v => v.ResourcePrefix);
            return string.IsNullOrEmpty(prefix) ? releaseName : $"{prefix}-{releaseName}";
        }

        private static bool IsHelmV3()
        {
            var env = new Dictionary<string, string>();
            string[] flags = { "version", "--short" };

            // Helm v2 returns version like this:
            // Client: v2.16.7+g5f2584f
            // Helm v3 returns a version like this:
            // v3.1.2+gd878d4d
            // --include-crds is available in helm v3.1+ so check for a regex matching that version
            var version = ExecuteCommand("helm", flags, env);
            Regex r = new Regex(@"^v3\.[1-9]");
            return r.IsMatch(version);
        }

        private void Fetch(string chart, ChartFetchArgsUnwrap opts)
        {
            var flags = new List<string>(new[] { "fetch", chart });

            // Untar by default.
            if (opts.Untar != false)
            {
                flags.Add("--untar");
            }

            var env = new Dictionary<string, string>();

            // Helm v3 removed the `--home` flag, so we must use an env var instead.
            if (!string.IsNullOrEmpty(opts.Home))
            {
                env["HELM_HOME"] = opts.Home;
            }

            if (!string.IsNullOrEmpty(opts.Version))
            {
                flags.Add("--version");
                flags.Add(opts.Version);
            }
            if (!string.IsNullOrEmpty(opts.CAFile))
            {
                flags.Add("--ca-file");
                flags.Add(opts.CAFile);
            }
            if (!string.IsNullOrEmpty(opts.CertFile))
            {
                flags.Add("--cert-file");
                flags.Add(opts.CertFile);
            }
            if (!string.IsNullOrEmpty(opts.KeyFile))
            {
                flags.Add("--key-file");
                flags.Add(opts.KeyFile);
            }
            if (!string.IsNullOrEmpty(opts.Destination))
            {
                flags.Add("--destination");
                flags.Add(opts.Destination);
            }
            if (!string.IsNullOrEmpty(opts.Keyring))
            {
                flags.Add("--keyring");
                flags.Add(opts.Keyring);
            }
            if (!string.IsNullOrEmpty(opts.Password))
            {
                flags.Add("--password");
                flags.Add(opts.Password);
            }
            if (!string.IsNullOrEmpty(opts.Repo))
            {
                flags.Add("--repo");
                flags.Add(opts.Repo);
            }
            if (!string.IsNullOrEmpty(opts.UntarDir))
            {
                flags.Add("--untardir");
                flags.Add(opts.UntarDir);
            }
            if (!string.IsNullOrEmpty(opts.Username))
            {
                flags.Add("--username");
                flags.Add(opts.Username);
            }
            if (opts.Devel == true)
            {
                flags.Add("--devel");
            }
            if (opts.Prov == true)
            {
                flags.Add("--prov");
            }
            if (opts.Verify == true)
            {
                flags.Add("--verify");
            }

            ExecuteCommand("helm", flags.ToArray(), env);
        }

        private Output<ImmutableDictionary<string, KubernetesResource>> ParseTemplate(string text,
            List<TransformationAction> transformations, string? resourcePrefix, ImmutableHashSet<Resource> dependsOn,
            string? defaultNamespace)
        {
            return Yaml.Invokes
                .YamlDecode(new YamlDecodeArgs { Text = text, DefaultNamespace = defaultNamespace })
                .Apply(objs =>
                {
                    var args = new ConfigGroupArgs
                    {
                        ResourcePrefix = resourcePrefix,
                        Objs = objs,
                        Transformations = transformations
                    };
                    var opts = new ComponentResourceOptions { Parent = this, DependsOn = dependsOn.ToArray() };
                    return Parser.Parse(args, opts);
                });
        }

        private static string ExecuteCommand(string command, string[] flags, IDictionary<string, string> env)
        {
            using var process = new Process
            {
                StartInfo =
                {
                    FileName = command,
                    Arguments = EscapeArguments(flags),
                    RedirectStandardOutput = true,
                    RedirectStandardError = true
                }
            };

            foreach (KeyValuePair<string, string> value in env)
            {
                process.StartInfo.EnvironmentVariables[value.Key] = value.Value;
            }

            process.Start();
            string output = process.StandardOutput.ReadToEnd();
            process.WaitForExit();
            if (process.ExitCode > 0)
            {
                string error = process.StandardError.ReadToEnd();
                throw new Exception(error);
            }
            return output;
        }

        /// <summary>
        /// Convert an argument array to an argument string for using with Process.StartInfo.Arguments.
        /// </summary>
        private static string EscapeArguments(params string[] args)
            => string.Join(" ", args.Select(EscapeArguments));

        /// <summary>
        /// Convert an argument array to an argument string for using with Process.StartInfo.Arguments.
        /// </summary>
        private static string EscapeArguments(string argument)
        {
            var escapedArgument = new StringBuilder();
            var backslashCount = 0;
            var needsQuotes = false;

            foreach (var character in argument)
            {
                switch (character)
                {
                    case '\\':
                        // Backslashes are simply passed through, except when they need
                        // to be escaped when followed by a \", e.g. the argument string
                        // \", which would be encoded to \\\"
                        backslashCount++;
                        escapedArgument.Append('\\');
                        break;

                    case '\"':
                        // Escape any preceding backslashes
                        escapedArgument.Append(new string('\\', backslashCount));

                        // Append an escaped double quote.
                        escapedArgument.Append("\\\"");

                        // Reset the backslash counter.
                        backslashCount = 0;
                        break;

                    case ' ':
                    case '\t':
                        // White spaces are escaped by surrounding the entire string with
                        // double quotes, which should be done at the end to prevent
                        // multiple wrappings.
                        needsQuotes = true;

                        // Append the whitespace
                        escapedArgument.Append(character);

                        // Reset the backslash counter.
                        backslashCount = 0;
                        break;

                    default:
                        // Reset the backslash counter.
                        backslashCount = 0;

                        // Append the current character
                        escapedArgument.Append(character);
                        break;
                }
            }

            // No need to wrap in quotes
            if (!needsQuotes)
            {
                return escapedArgument.ToString();
            }

            // Prepend the "
            escapedArgument.Insert(0, '"');

            // Escape any preceding backslashes before appending the "
            escapedArgument.Append(new string('\\', backslashCount));

            // Append the final "
            escapedArgument.Append('\"');

            return escapedArgument.ToString();
        }
    }
}
